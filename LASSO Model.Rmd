---
title: "LASSO"
output: html_document
date: "2025-11-14"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}

library(glmnet)
library(caret)
library(pROC)
```

```{r}
metabric <- read.csv("C:/Users/afw3uz/Downloads/metabric.csv", stringsAsFactors = FALSE)
```

```{r}
outcome_col <- "overall_survival"
metabric[[outcome_col]] <- as.integer(metabric[[outcome_col]])
metabric <- metabric[!is.na(metabric[[outcome_col]]), ]

y <- metabric[[outcome_col]]


```

```{R}
exclude_vars <- c(
  "patient_id",
  "overall_survival",         
  "overall_survival_months",   
  "death_from_cancer",         
  "cancer_type"                
)

exclude_vars <- intersect(exclude_vars, names(metabric))

predictor_vars <- setdiff(names(metabric), exclude_vars)

predictors <- metabric[, predictor_vars, drop = FALSE]
```

```{r}
char_cols <- sapply(predictors, is.character)

predictors[char_cols] <- lapply(predictors[char_cols], function(x) {
  x[x == ""] <- NA
  x
})


predictors[char_cols] <- lapply(predictors[char_cols], factor)

```

```{r}
num_cols <- sapply(predictors, is.numeric)

pre_num <- preProcess(
  predictors[, num_cols, drop = FALSE],
  method = c("medianImpute")
)

predictors_num_imp <- predict(pre_num, predictors[, num_cols, drop = FALSE])

```

```{r}
predictors_cat <- predictors[, !num_cols, drop = FALSE]

fac_cols <- sapply(predictors_cat, is.factor)

predictors_cat[fac_cols] <- lapply(predictors_cat[fac_cols], function(x) {
  x <- addNA(x)
  lev <- levels(x)
  lev[is.na(lev)] <- "Missing"
  levels(x) <- lev
  x
})

merge_rare_levels <- function(f, min_count = 10) {
  tab <- table(f)
  rare_levels <- names(tab[tab < min_count])
  if (length(rare_levels) > 0) {
    f <- factor(ifelse(f %in% rare_levels, "Other", as.character(f)))
  } else {
    f <- factor(f)
  }
  f
}

predictors_cat[fac_cols] <- lapply(predictors_cat[fac_cols], merge_rare_levels)
```

```{r}
if (ncol(predictors_num_imp) > 0) {
  num_var <- apply(predictors_num_imp, 2, var, na.rm = TRUE)
  num_var[is.na(num_var)] <- 0
  k <- min(150, length(num_var))  # keep up to 150
  high_var_idx <- order(num_var, decreasing = TRUE)[1:k]
  predictors_num_imp_hv <- predictors_num_imp[, high_var_idx, drop = FALSE]
} else {
  predictors_num_imp_hv <- predictors_num_imp
}

```

```{r}
predictors_imp <- cbind(
  predictors_num_imp_hv,
  predictors_cat
)

```

```{r}
nzv_idx <- nearZeroVar(predictors_imp)

if (length(nzv_idx) > 0) {
  predictors_red <- predictors_imp[, -nzv_idx, drop = FALSE]
} else {
  predictors_red <- predictors_imp
}

```

```{r}
needed_cols <- c("er_status", "pr_status", "her2_status",
                 "tumor_size", "neoplasm_histologic_grade",
                 "lymph_nodes_examined_positive")

existing <- intersect(needed_cols, colnames(predictors_red))

if (all(c("er_status", "pr_status") %in% existing)) {
  predictors_red$ER_PR <- with(predictors_red, er_status:pr_status)
}

if (all(c("er_status", "her2_status") %in% existing)) {
  predictors_red$ER_HER2 <- with(predictors_red, er_status:her2_status)
}

if (all(c("tumor_size", "neoplasm_histologic_grade") %in% existing)) {
  predictors_red$TS_GRADE <- predictors_red$tumor_size *
    predictors_red$neoplasm_histologic_grade
}

if (all(c("tumor_size", "lymph_nodes_examined_positive") %in% existing)) {
  predictors_red$TS_LN <- predictors_red$tumor_size *
    predictors_red$lymph_nodes_examined_positive
}

```

```{r}
X <- model.matrix(~ ., data = predictors_red)[, -1]  
dim(X) 
```

```{r}
w <- ifelse(y == 1,
            1 / mean(y == 1),
            1 / mean(y == 0))
```

```{r}
set.seed(123)

cv_lasso <- cv.glmnet(
  x = X,
  y = y,
  family = "binomial",
  alpha = 1,            
  nfolds = 10,
  type.measure = "auc",
  standardize = FALSE,
  weights = w
)

plot(cv_lasso, main = "LASSO (alpha = 1) CV Curve with Class Weights")
```

```{r}
prob <- predict(
  cv_lasso,
  newx = X,
  s = "lambda.min",
  type = "response"
)
```

```{r}
best_thresh <- coords(
  roc_lasso,
  x = "best",
  best.method = "youden",
  ret = "threshold"
)

best_thresh <- as.numeric(best_thresh) 

pred <- ifelse(prob >= best_thresh, 1, 0)
```

```{r}
accuracy_lasso <- mean(pred == y)

pred_fac <- factor(pred, levels = c(0, 1))
y_fac    <- factor(y,   levels = c(0, 1))

f1_1 <- F_meas(pred_fac, y_fac, relevant = "1")
f1_0 <- F_meas(pred_fac, y_fac, relevant = "0")
f1_macro_lasso <- (f1_1 + f1_0) / 2


auc_lasso <- auc(roc_lasso)

accuracy_lasso
f1_macro_lasso
auc_lasso

plot(
  roc_lasso,
  col = "blue",
  lwd = 2,
  main = paste0("ROC Curve for LASSO (AUC = ",
                round(auc_lasso, 3), ")")
)
```

```{r}
coef_min <- coef(cv_lasso, s = "lambda.min")

coef_df <- data.frame(
  feature = rownames(coef_min),
  coef    = as.numeric(coef_min)
)

coef_imp <- subset(coef_df, feature != "(Intercept)" & coef != 0)
coef_imp$abscoef <- abs(coef_imp$coef)

head(coef_imp[order(-coef_imp$abscoef), ], 20)

```